<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
<script>
// function Foo() { // 定义了一个叫Foo的函数
//   getName = function () { alert (1); };  // 创建了一个getName的静态属性存储了一个匿名函数
//   return this;
// }
// Foo.getName = function () { alert (2);};
// Foo.prototype.getName = function () { alert (3);};    // Foo 的原型对象新创建了一个叫getName的匿名函数
// var getName = function () { alert (4);};   // 通过函数表达式创建了一个getName 的函数
// function getName() { alert (5);}   // 最后声明了一个叫getName的函数

//请写出以下输出结果：
// Foo.getName(); // 2
// getName();   //4
// Foo().getName();  //1
// getName();  // 1  ？？？
// new Foo.getName(); // 2 ?
// new Foo().getName(); // 3
// new new Foo().getName(); // 3

/**
* 先看此题的上半部分做了什么，首先定义了一个叫Foo的函数，之后为Foo创建了一个getName的静态属性存储了一个匿名函数，之后Foo的原型对象新创建了一个叫getName 的匿名函数。之后又通过函数表达式创建了一个getName的函数，最后再声明了一个叫getName的函数


一问：Foo.getName 自然是访问Foo函数上存储的静态属性，答案自然事2
*/
// function User(name){
//   var name = name;  // 私有属性
//   this.name = name; // 公有属性
//   function getName(){ //私有方法
//     return name;
//   }
// }
// User.prototype.getName= function(){  // 公有方法
//   return this.name;
// }
// User.name = 'wscats'; // 静态属性
// User.getName = function(){ // 静态方法
//   return this.name;
// }
// var Wscat = new User('Wscats'); //实例化

// 注意点：调用公有方法，公有属性，我们必须先实例化对象，也就是new操作符实化对象，就可构造函数实例化对象的方法和属性，并且公有方法是不能调用私有方法和静态方法的
// 静态方法和静态属性就是我们无需实例化就可以调用
// 而对象的私有方法和属性，外部是不可以访问的

/*
二问，直接调用getName函数。既然是直接调用那么就是访问当前上文作用域内的叫 getName的函数，所以这里应该直接把关注点放在4和5上，跟1 2 3 都没关系。此处有两个坑，一是变量声明提升，二是函数表达式和函数声明的区别。

https://github.com/Wscats/Good-text-Share/issues/73    // 关于js的函数声明和函数表达式
https://github.com/Wscats/Good-text-Share/issues/86    // 关于js 变量提升
*/
// 再JS中，定义函数有两种类型
// function wscat(type){  // 函数声明
//   return type === 'wscat'
// }
// var oaoafly = function(type){  // 函数表达式
//   return type === 'oaoafly'
// }

// 在一个程序里面同时用函数声明呵函数表达式定义一个getName得函数
// getName() // oaoafly
// var getName = function(){
//   console.log('wacat');
// }
// getName(); //wacat
// function(){
//   console.log('oaoafly');
// }
// getName(); // wacat
// 上面代码看起来很类似，赶紧没什么差别。实际上，js函数上得一个“陷阱”就体现再js两种类型得函数定义上
// · js解释器中存在一种变量声明被提升得机制，也就是说函数声明会被提升到作用域得最前面，即使写代码得时候是写再最后面，也还是会被提升至最前面。
// · 而用函数表达式创建得函数是再运行时进行赋值，且要等到表达式赋值完成后才能调用
// var getName; // 变量被提升，此时为undefined
// getName();   // oaoafly 函数被提升，这里受函数声明得影响，虽然函数声明再最后可以被提升到最前面
// var getName = function(){
//   console.log('wacat')
// }; // 函数表达式此时才开始覆盖函数声明得定义
// getName(); // wacat
// function getName(){
//   console.log('oaoafly');
// }
// getName(); // wacat 这里执行了函数表达式得值

// 可以分解这两个简单得问题来看清楚区别得本质
// var getName;
// console.log(getName) // undefined
// getName();  // Uncaught TypeError:getName is not a function
// var getName = function(){
//   console.log('wscat')
// }
// var getName;
// console.log(getName); // function getName(){ console.log('oaoafly') };
// getName(); //oaoafly
// function getName(){ console.log('oaoafly') }
// 这个区别看似微不足道，但再某些情况下确实是一个难以察觉并且“致命”得陷阱。出现这个陷阱得本质原因体现再这两种类型再函数提升和运行时机（解析时/运行时）上得差异；
// 总结：JavaScript中函数声明和函数表达式是存在区别得，函数声明再JS解析时进行函数提升，因此再同一个作用于内，不管函数声明在哪里定义，该函数都可以进行调用。而函数表达式得值是再JS运行时确定，并且再表达式赋值完成后，该函数才能调用。so 第二问得答案4，5得函数声明被4得函数表达式覆盖了；

// 三问 Foo().getName(); 先执行了Foo函数，然后调用了Foo函数得返回值对象得getName属性函数。Foo函数得第一句 getName = function(){ alert(1); } 是一句函数赋值语句，注意它没有var声明，所以先向当前Foo函数作用域内寻找getName变量，没有，再向当前函数作用域上层，即外层作用域内寻找是否含有getName变量，找到了，也就是第二问中得alert(4)函数，将此变量得值赋值为function(){alert(1)}.此处实际上是将外层作用域内得getName函数修改了。
// PS：此处若依然没有找到会一直向上查找得window对象，若window对象中也没有getName属性，就再window对象中创建一个getName函数修改了。
// 之后Foo函数得返回值this,简单得说，this得执行是由所在函数得调用方式决定得。而此处得直接调用方式，this指向window对象。Foo函数返回得是window对象，相当与执行window.getName(),而window中得getName已经被修改为alert（1），所以最终会输出1
// 两个知识点，一个是变量作用域问题，一个是this指向问题。
var name = 'Wscats'; // 全局变量
window.name = 'Wscats'; // 全局变量
function getName(){
  name = 'Oaoafly'; // 去掉var 就变成了全局变量
  var priveateName = 'Stacsw';
  return function(){
    console.log(this); // window
    return priveateName
  }
}
var getPrivte = getName("hello"); // 当然传参是局部变量，但函数里面我没有接受这个参数
console.log(name); // Oaoafly
console.log(getPrivte);
console.log(getPrivte()); // Stacsw
</script>
</body>
</html>
