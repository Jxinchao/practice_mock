<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
<script>
function Foo() { // 定义了一个叫Foo的函数
  getName = function () { alert (1); };  // 创建了一个getName的静态属性存储了一个匿名函数
  return this;
}
Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};    // Foo 的原型对象新创建了一个叫getName的匿名函数
var getName = function () { alert (4);};   // 通过函数表达式创建了一个getName 的函数
function getName() { alert (5);}   // 最后声明了一个叫getName的函数

//请写出以下输出结果：
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();

/**
* 先看此题的上半部分做了什么，首先定义了一个叫Foo的函数，之后为Foo创建了一个getName的静态属性存储了一个匿名函数，之后Foo的原型对象新创建了一个叫getName 的匿名函数。之后又通过函数表达式创建了一个getName的函数，最后再声明了一个叫getName的函数


一问：Foo.getName 自然是访问Foo函数上存储的静态属性，答案自然事2
*/
function User(name){
  var name = name;  // 私有属性
  this.name = name; // 公有属性
  function getName(){ //私有方法
    return name;
  }
}
User.prototype.getName= function(){  // 公有方法
  return this.name;
}
User.name = 'wscats'; // 静态属性
User.getName = function(){ // 静态方法
  return this.name;
}
var Wscat = new User('Wscats'); //实例化

// 注意点：调用公有方法，公有属性，我们必须先实例化对象，也就是new操作符实化对象，就可构造函数实例化对象的方法和属性，并且公有方法是不能调用私有方法和静态方法的
// 静态方法和静态属性就是我们无需实例化就可以调用
// 而对象的私有方法和属性，外部是不可以访问的

/*
二问，直接调用getName函数。既然是直接调用那么就是访问当前上文作用域内的叫 getName的函数，所以这里应该直接把关注点放在4和5上，跟1 2 3 都没关系。此处有两个坑，一是变量声明提升，二是函数表达式和函数声明的区别。

https://github.com/Wscats/Good-text-Share/issues/73    // 关于js的函数声明和函数表达式
https://github.com/Wscats/Good-text-Share/issues/86    // 关于js 变量提升
*/
</script>
</body>
</html>
